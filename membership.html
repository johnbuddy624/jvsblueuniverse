<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D World Builder Fixed</title>
<style>
body {margin:0; overflow:hidden;}
canvas {display:block;}
#instructions {
 position:fixed; top:10px; left:10px; color:white; font-family:sans-serif; z-index:10;
 background:rgba(0,0,0,0.3); padding:5px; border-radius:5px;
}
#blockSelect {
 position:fixed; top:130px; left:10px; color:white; z-index:10; background:rgba(0,0,0,0.3);
 padding:5px; border-radius:5px; font-family:sans-serif;
}
</style>
</head>
<body>
<div id="instructions">
Click to lock pointer.<br>
W/A/S/D: Move | Space: Jump | Mouse: Look<br>
Left Click: Place block | Right Click: Remove block
</div>
<div id="blockSelect">
Block: 
<select id="blockType">
<option value="grass">Grass</option>
<option value="stone">Stone</option>
<option value="dirt">Dirt</option>
<option value="wood">Wood</option>
</select>
<button id="saveBtn">Save</button>
<button id="loadBtn">Load</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/PointerLockControls.js"></script>
<script>
// =========================
// SCENE SETUP
// =========================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // sky blue

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,2,5);

// RENDERER
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// LIGHTS
const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5,10,5);
dirLight.castShadow=true;
scene.add(dirLight);

// =========================
// CONTROLS
// =========================
const controls = new THREE.PointerLockControls(camera, document.body);
document.body.addEventListener('click', ()=>{controls.lock();});

// =========================
// PLAYER
// =========================
const player = {x:0, y:2, z:0, vx:0, vy:0, vz:0, speed:5, jumpPower:7, onGround:false};
const move = {forward:false, back:false, left:false, right:false};
document.addEventListener('keydown', e=>{
 if(e.code==='KeyW') move.forward=true;
 if(e.code==='KeyS') move.back=true;
 if(e.code==='KeyA') move.left=true;
 if(e.code==='KeyD') move.right=true;
 if(e.code==='Space' && player.onGround){player.vy=player.jumpPower; player.onGround=false;}
});
document.addEventListener('keyup', e=>{
 if(e.code==='KeyW') move.forward=false;
 if(e.code==='KeyS') move.back=false;
 if(e.code==='KeyA') move.left=false;
 if(e.code==='KeyD') move.right=false;
});

// =========================
// BLOCKS
// =========================
const blockSize = 1;
const blockMaterials = {
 grass: new THREE.MeshLambertMaterial({color:0x00ff00}),
 stone: new THREE.MeshLambertMaterial({color:0x888888}),
 dirt:  new THREE.MeshLambertMaterial({color:0x964B00}),
 wood:  new THREE.MeshLambertMaterial({color:0xDEB887}),
};
let blockType = 'grass';
document.getElementById('blockType').addEventListener('change', e=>blockType=e.target.value);

// =========================
// WORLD DATA
// =========================
const cubesGroup = new THREE.Group();
scene.add(cubesGroup);
const worldData = {};

// Helper to add/remove blocks
function addBlock(x,y,z,type){
 const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
 const cube = new THREE.Mesh(geometry, blockMaterials[type]);
 cube.position.set(x,y,z);
 cube.castShadow=true;
 cube.receiveShadow=true;
 cubesGroup.add(cube);
 worldData[`${x},${y},${z}`]=type;
}
function removeBlock(x,y,z){
 for(let i=cubesGroup.children.length-1;i>=0;i--){
   const c = cubesGroup.children[i];
   if(c.position.x===x && c.position.y===y && c.position.z===z){
     cubesGroup.remove(c);
     delete worldData[`${x},${y},${z}`];
     break;
   }
 }
}

// Create initial floor
for(let x=-10;x<=10;x++){
 for(let z=-10;z<=10;z++){
   addBlock(x,0,z,'grass');
 }
}

// =========================
// MOUSE INTERACTION
// =========================
const raycaster = new THREE.Raycaster();
window.addEventListener('mousedown', e=>{
 e.preventDefault();
 raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
 const intersects = raycaster.intersectObjects(cubesGroup.children);
 if(intersects.length>0){
   const point = intersects[0].point;
   const normal = intersects[0].face.normal;
   const targetPos = intersects[0].object.position.clone().add(normal);
   targetPos.x=Math.round(targetPos.x);
   targetPos.y=Math.round(targetPos.y);
   targetPos.z=Math.round(targetPos.z);
   if(e.button===0) addBlock(targetPos.x,targetPos.y,targetPos.z,blockType);
   if(e.button===2) removeBlock(intersects[0].object.position.x, intersects[0].object.position.y, intersects[0].object.position.z);
 }
});
window.addEventListener('contextmenu', e=>e.preventDefault());

// =========================
// SAVE / LOAD
// =========================
document.getElementById('saveBtn').addEventListener('click', ()=>{
 localStorage.setItem('my3DWorld',JSON.stringify(worldData));
 alert('World saved!');
});
document.getElementById('loadBtn').addEventListener('click', ()=>{
 const data = JSON.parse(localStorage.getItem('my3DWorld'));
 if(data){
   cubesGroup.clear();
   Object.keys(data).forEach(k=>{
     const [x,y,z] = k.split(',').map(Number);
     addBlock(x,y,z,data[k]);
   });
   alert('World loaded!');
 }
});

// =========================
// ANIMATION LOOP
// =========================
const clock = new THREE.Clock();
function animate(){
 requestAnimationFrame(animate);
 const delta = clock.getDelta();

 // Player movement
 player.vx=player.vz=0;
 if(move.forward) player.vz -= player.speed*delta;
 if(move.back) player.vz += player.speed*delta;
 if(move.left) player.vx -= player.speed*delta;
 if(move.right) player.vx += player.speed*delta;
 player.vy -= 9.8*delta; // gravity

 // Collision detection
 const playerBox = new THREE.Box3(
   new THREE.Vector3(player.x-0.25, player.y-0.5, player.z-0.25),
   new THREE.Vector3(player.x+0.25, player.y+0.5, player.z+0.25)
 );
 player.onGround=false;
 cubesGroup.children.forEach(c=>{
   const cubeBox = new THREE.Box3().setFromObject(c);
   if(playerBox.intersectsBox(cubeBox)){
     // Collide from top
     if(player.vy<0 && player.y>c.position.y){
       player.y=c.position.y+1; player.vy=0; player.onGround=true;
     }
     // Simple horizontal collision
     if(playerBox.min.x<cubeBox.max.x && playerBox.max.x>cubeBox.min.x) player.x -= player.vx;
     if(playerBox.min.z<cubeBox.max.z && playerBox.max.z>cubeBox.min.z) player.z -= player.vz;
   }
 });

 player.x += player.vx;
 player.y += player.vy*delta;
 player.z += player.vz;

 camera.position.set(player.x, player.y+0.5, player.z);
 renderer.render(scene, camera);
}
animate();

// =========================
// RESIZE
// =========================
window.addEventListener('resize', ()=>{
 camera.aspect = window.innerWidth/window.innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>