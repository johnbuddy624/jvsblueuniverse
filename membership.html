<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wizardâ€™s Puzzle Adventure</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#111;}
canvas{display:block;margin:0 auto;background:#111;}
#ui{position:fixed;top:10px;left:10px;color:#0ff;font-size:18px;z-index:10;}
#message{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);color:#ff0;font-size:16px;z-index:10;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">Lives: <span id="lives">5</span> | Score: <span id="score">0</span> | Level: <span id="level">1</span></div>
<script>
// =========================
// SETTINGS
// =========================
const TILE=32, ROOM_WIDTH=12, ROOM_HEIGHT=10;
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
let width=canvas.width=window.innerWidth;
let height=canvas.height=window.innerHeight;
window.addEventListener('resize',()=>{width=canvas.width=window.innerWidth;height=canvas.height=window.innerHeight;});

// =========================
// PLAYER
// =========================
const player={
 x:TILE*1, y:TILE*(ROOM_HEIGHT-2),
 w:28, h:28,
 vx:0, vy:0,
 speed:3,
 jumpPower:8,
 onGround:false,
 lives:5,
 score:0
};

// =========================
// INPUT
// =========================
const keysDown={};
window.addEventListener('keydown',e=>keysDown[e.key]=true);
window.addEventListener('keyup',e=>keysDown[e.key]=false);

// =========================
// PARTICLES
// =========================
let particles=[];
function createParticle(x,y,color){
 for(let i=0;i<10;i++){
   particles.push({x,y,vx:(Math.random()-0.5)*4,vy:(Math.random()-1.5)*4,l:20,color});
 }
}

// =========================
// SOUNDS
// =========================
function playSound(type){
 const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
 const osc = audioCtx.createOscillator();
 osc.type="square";
 osc.frequency.setValueAtTime(type==='jump'?500:type==='block'?300:400,audioCtx.currentTime);
 osc.connect(audioCtx.destination);
 osc.start();
 osc.stop(audioCtx.currentTime+0.1);
}

// =========================
// MAPS / LEVELS
// 0=empty,1=wall,2=enemy,3=key,4=exit
// =========================
const levels=[
[
[1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,3,1],
[1,0,2,0,0,2,0,0,2,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,0,1,0,1,0,1,0,1,1],
[1,0,0,0,0,0,0,0,0,0,0,1],
[1,0,2,0,0,2,0,0,2,0,0,1],
[1,0,0,0,0,0,0,0,0,0,4,1],
[1,0,0,2,0,0,2,0,0,2,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1]
],
[
[1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,2,0,0,0,2,0,3,1],
[1,0,0,0,0,0,0,0,0,0,0,1],
[1,2,0,2,0,2,0,2,0,2,0,1],
[1,0,0,0,0,0,0,0,0,0,0,1],
[1,0,2,0,0,2,0,0,2,0,0,1],
[1,0,0,0,0,0,0,0,0,0,4,1],
[1,0,2,0,0,2,0,0,2,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1]
]
];

let levelIndex=0;
let map=[];
let enemies=[];

// =========================
// LOAD LEVEL
// =========================
function loadLevel(){
 map=JSON.parse(JSON.stringify(levels[levelIndex]));
 enemies=[];
 for(let y=0;y<ROOM_HEIGHT;y++){
   for(let x=0;x<ROOM_WIDTH;x++){
     if(map[y][x]===2) enemies.push({x:x*TILE,y:y*TILE,w:28,h:28,vx:1});
   }
 }
 player.x=TILE*1; player.y=TILE*(ROOM_HEIGHT-2); player.vx=0; player.vy=0;
 document.getElementById('level').textContent=levelIndex+1;
}
loadLevel();

// =========================
// UPDATE
// =========================
function update(){
 // Horizontal movement
 if(keysDown['ArrowLeft']) player.vx=-player.speed;
 else if(keysDown['ArrowRight']) player.vx=player.speed;
 else player.vx=0;

 // Jump
 if(keysDown['ArrowUp'] && player.onGround){player.vy=-player.jumpPower;player.onGround=false; playSound('jump');}

 // Gravity
 player.vy+=0.5; player.onGround=false;

 // Apply movement
 player.x+=player.vx;
 player.y+=player.vy;

 // Collision
 for(let y=0;y<ROOM_HEIGHT;y++){
   for(let x=0;x<ROOM_WIDTH;x++){
     const tile=map[y][x];
     if(tile===1){
       const tx=x*TILE, ty=y*TILE;
       if(player.x+player.w>tx && player.x<tx+TILE && player.y+player.h>ty && player.y<ty+TILE){
         // Simple collision resolution
         if(player.vy>0) {player.y=ty-player.h; player.vy=0; player.onGround=true;}
         else if(player.vy<0){player.y=ty+TILE; player.vy=0;}
         if(player.vx>0) player.x=tx-player.w;
         else if(player.vx<0) player.x=tx+TILE;
       }
     }
   }
 }

 // Enemy movement
 enemies.forEach(e=>{
   e.x+=e.vx;
   if(e.x<0 || e.x+e.w>ROOM_WIDTH*TILE) e.vx*=-1;
   // Collision with player
   if(player.x<e.x+e.w && player.x+player.w>e.x && player.y<e.y+e.h && player.y+player.h>e.y){
     player.lives--; document.getElementById('lives').textContent=player.lives;
     createParticle(player.x+player.w/2,player.y+player.h/2,'#f00');
     if(player.lives<=0){ alert('Game Over! Score:'+player.score); location.reload();}
   }
 });

 // Key/Exit collection
 for(let y=0;y<ROOM_HEIGHT;y++){
   for(let x=0;x<ROOM_WIDTH;x++){
     if(map[y][x]===3 && player.x<TILE*x+TILE && player.x+player.w>TILE*x && player.y<TILE*y+TILE && player.y+player.h>TILE*y){
       map[y][x]=0; player.score+=100; document.getElementById('score').textContent=player.score;
       createParticle(player.x+player.w/2,player.y+player.h/2,'#ff0'); playSound('block');
     }
     if(map[y][x]===4 && player.x<TILE*x+TILE && player.x+player.w>TILE*x && player.y<TILE*y+TILE && player.y+player.h>TILE*y){
       levelIndex=(levelIndex+1)%levels.length; loadLevel();
     }
   }
 }

// Update particles
 particles.forEach((p,i)=>{
   p.x+=p.vx; p.y+=p.vy; p.l--;
   if(p.l<=0) particles.splice(i,1);
 });
}

// =========================
// DRAW
// =========================
function draw(){
 ctx.clearRect(0,0,width,height);

 // Draw tiles
 for(let y=0;y<ROOM_HEIGHT;y++){
   for(let x=0;x<ROOM_WIDTH;x++){
     const tile=map[y][x];
     if(tile===1) ctx.fillStyle='#666',ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
     if(tile===3) ctx.fillStyle='#ff0',ctx.fillRect(x*TILE+8,y*TILE+8,TILE-16,TILE-16);
     if(tile===4) ctx.fillStyle='#0f0',ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
   }
 }

 // Draw enemies
 enemies.forEach(e=>ctx.fillStyle='#f00',ctx.fillRect(e.x,e.y,e.w,e.h));

 // Draw particles
 particles.forEach(p=>{ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,4,4);});

 // Draw player
 ctx.fillStyle='#0ff'; ctx.fillRect(player.x,player.y,player.w,player.h);
}

// =========================
// MAIN LOOP
// =========================
function loop(){update(); draw(); requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>