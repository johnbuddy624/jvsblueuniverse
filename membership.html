<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NEON HYPERSPACE</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{margin:0;overflow:hidden;background:black}
#ui{
 position:fixed;top:15px;left:15px;
 color:#0ff;font:20px system-ui;z-index:10
}
</style>
</head>
<body>

<div id="ui">Score: <span id="score">0</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
let score=0;
const scene=new THREE.Scene();
scene.fog=new THREE.Fog(0x000000,10,60);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.z=10;

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Bloom
const composer=new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene,camera));
const bloom=new THREE.UnrealBloomPass(
 new THREE.Vector2(innerWidth,innerHeight),
 1.5,0.4,0.1
);
composer.addPass(bloom);

// Lights
scene.add(new THREE.AmbientLight(0x404040));
const light=new THREE.PointLight(0x00ffff,2,50);
scene.add(light);

// Player
const ship=new THREE.Mesh(
 new THREE.SphereGeometry(0.4,32,32),
 new THREE.MeshStandardMaterial({
  color:0x00ffff,
  emissive:0x00ffff,
  emissiveIntensity:2
 })
);
scene.add(ship);

// Stars
const starGeo=new THREE.BufferGeometry();
const starCount=2000;
const pos=[];
for(let i=0;i<starCount;i++){
 pos.push(
  (Math.random()-.5)*200,
  (Math.random()-.5)*200,
  -Math.random()*200
 );
}
starGeo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
const stars=new THREE.Points(
 starGeo,
 new THREE.PointsMaterial({
  color:0xffffff,
  size:0.15
 })
);
scene.add(stars);

// Enemies
const enemies=[];
function spawnEnemy(){
 const e=new THREE.Mesh(
  new THREE.IcosahedronGeometry(0.6,1),
  new THREE.MeshStandardMaterial({
   color:0xff0033,
   emissive:0xff0033,
   emissiveIntensity:2
  })
 );
 e.position.set((Math.random()-.5)*8,6,-10);
 scene.add(e);
 enemies.push(e);
}
setInterval(spawnEnemy,800);

// Input
addEventListener("mousemove",e=>{
 ship.position.x=(e.clientX/innerWidth-.5)*8;
 ship.position.y=-(e.clientY/innerHeight-.5)*6;
});

// Resize
addEventListener("resize",()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
 composer.setSize(innerWidth,innerHeight);
});

function animate(){
 requestAnimationFrame(animate);

 // Stars move
 stars.rotation.y+=0.0005;
 stars.position.z+=0.4;
 if(stars.position.z>0)stars.position.z=-200;

 // Enemies
 enemies.forEach((e,i)=>{
  e.position.z+=0.3;
  e.rotation.x+=0.01;
  e.rotation.y+=0.01;

  if(e.position.distanceTo(ship.position)<0.8){
   alert("GAME OVER\nScore: "+score);
   location.reload();
  }
  if(e.position.z>10){
   scene.remove(e);
   enemies.splice(i,1);
   score++;
   document.getElementById("score").textContent=score;
  }
 });

 // Camera drift
 camera.position.x+=(ship.position.x-camera.position.x)*0.05;
 camera.position.y+=(ship.position.y-camera.position.y)*0.05;

 light.position.copy(ship.position);

 composer.render();
}
animate();
</script>
</body>
</html>