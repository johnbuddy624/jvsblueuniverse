<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>J&V’s Blue Universe – Starfield Home</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: black;
  overflow: hidden;
  width: 100%;
  height: 100%;
}
canvas {
  position: fixed;
  inset: 0;
  z-index: 1;
}
</style>
</head>
<body>

<canvas id="space"></canvas>

<script>
/* =========================
  CURRENT BLUEPRINT
  =========================
  Stars: 800, size 0.5-2px, z-depth 0.2-1, alpha 0.2-1
  Shooting Stars: spawn chance 0.01 per frame, trail 30px, RGB "255,255,255"
  Cosmic Worm:
    - Head radius: 15px
    - Segments: 25 for flowing length
    - Body: rgba(0,150,255,0.9)
    - Mist trail: rgba(255,255,100,0.25)
    - Wiggle via segment-following
    - Tail follows head, fading in alpha & radius
    - Head clamped to canvas edges
    - Works on desktop + mobile
  Text Object: "J&V's"
    - Top-center
    - Size: 80px
    - Color: cloudy blue
    - Fixed smooth pulse 0 → 1 alpha
  Locked: Stars, shooting stars, canvas background remain untouched
  Notes for future dev: Segment count, size, velocity, gradient stops adjustable. Keep locked elements safe.
========================= */

/* ===== CANVAS SETUP ===== */
const canvas = document.getElementById("space");
const ctx = canvas.getContext("2d");
let w, h;
function resize() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
window.addEventListener("resize", resize);
resize();

/* ===== STARFIELD ===== */
const stars = Array.from({length:800},() => ({
  x:Math.random()*w,
  y:Math.random()*h,
  z:Math.random()*0.8+0.2,
  a:Math.random()*0.8+0.2,
  r:Math.random()*1.5+0.5
}));

let px=0, py=0;
window.addEventListener("mousemove", e => { px=(e.clientX-w/2)/100; py=(e.clientY-h/2)/100; });
window.addEventListener("deviceorientation", e => { px=(e.gamma||0)/45*100; py=(e.beta||0)/45*100; });

/* ===== SHOOTING STARS ===== */
let shootingStars=[];
function spawnShootingStar(){
  shootingStars.push({
    x:Math.random()*w,
    y:Math.random()*h,
    vx:(Math.random()*6-3),
    vy:(Math.random()*6-3),
    width:Math.random()*1.5+1,
    trail:30,
    color:"255,255,255"
  });
}
setInterval(()=>{if(Math.random()<0.01) spawnShootingStar();},50);

/* ===== COSMIC WORM ===== */
const worm = {
  segments:25,
  positions:[],
  size:15,
  color:"rgba(0,150,255,0.9)",
  mistColor:"rgba(255,255,100,0.25)",
  vx:(Math.random()-0.5)*1.5,
  vy:(Math.random()-0.5)*1.5
};
for(let i=0;i<worm.segments;i++){ worm.positions.push({x:w/2,y:h/2}); }

/* ===== 3D TEXT OBJECT ("J&V's") ===== */
const textObj = {
  text:"J&V's",
  size:80,
  x:w/2,
  y:100,
  baseAlpha:0,
  pulseSpeed:0.02,
  alphaDirection:1,
  color:"rgba(100,150,255,ALPHA)" // cloudy blue, ALPHA replaced per frame
};

/* ===== DRAW FUNCTIONS ===== */
function drawStars(){
  stars.forEach(s=>{
    ctx.globalAlpha=s.a*s.z;
    ctx.beginPath();
    ctx.arc(s.x+px*s.z,s.y+py*s.z,s.r*s.z,0,Math.PI*2);
    ctx.fillStyle="white";
    ctx.fill();
  });
}

function drawShootingStars(){
  shootingStars.forEach((s,i)=>{
    const tail=s.trail;
    const grad=ctx.createLinearGradient(s.x,s.y,s.x-s.vx*tail,s.y-s.vy*tail);
    grad.addColorStop(0,`rgba(${s.color},0.9)`);
    grad.addColorStop(0.3,`rgba(${s.color},0.5)`);
    grad.addColorStop(1,`rgba(${s.color},0)`);
    ctx.strokeStyle=grad;
    ctx.lineWidth=s.width;
    ctx.lineCap="round";
    ctx.beginPath();
    ctx.moveTo(s.x,s.y);
    ctx.lineTo(s.x-s.vx*tail,s.y-s.vy*tail);
    ctx.stroke();
    s.x+=s.vx;
    s.y+=s.vy;
    if(s.x<-100||s.x>w+100||s.y<-100||s.y>h+100) shootingStars.splice(i,1);
  });
}

function drawWorm(){
  for(let i=0;i<worm.segments;i++){
    const pos=worm.positions[i];
    const radius=worm.size*(1-i*0.04);
    const alpha=1-i*0.04;
    const grad=ctx.createRadialGradient(pos.x,pos.y,0,pos.x,pos.y,radius*2);
    grad.addColorStop(0,worm.color);
    grad.addColorStop(0.5,worm.mistColor);
    grad.addColorStop(1,"rgba(0,0,0,0)");
    ctx.beginPath();
    ctx.arc(pos.x,pos.y,radius*2,0,Math.PI*2);
    ctx.fillStyle=grad;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(pos.x,pos.y,radius,0,Math.PI*2);
    ctx.fillStyle=worm.color;
    ctx.fill();
  }
}

function updateWorm(){
  let head=worm.positions[0];
  worm.vx+=(Math.random()-0.5)*0.3;
  worm.vy+=(Math.random()-0.5)*0.3;
  worm.vx=Math.max(Math.min(worm.vx,1.5),-1.5);
  worm.vy=Math.max(Math.min(worm.vy,1.5),-1.5);
  head.x+=worm.vx;
  head.y+=worm.vy;
  if(head.x<0){head.x=0;worm.vx*=-1;}
  if(head.x>w){head.x=w;worm.vx*=-1;}
  if(head.y<0){head.y=0;worm.vy*=-1;}
  if(head.y>h){head.y=h;worm.vy*=-1;}
  
  for(let i=1;i<worm.segments;i++){
    const prev=worm.positions[i-1];
    const cur=worm.positions[i];
    cur.x+=(prev.x-cur.x)*0.2;
    cur.y+=(prev.y-cur.y)*0.2;
  }
}

function drawTextObj(){
  // ===== FIXED JV PULSE =====
  textObj.baseAlpha += textObj.pulseSpeed * textObj.alphaDirection;
  if(textObj.baseAlpha>1){textObj.baseAlpha=1;textObj.alphaDirection=-1;}
  if(textObj.baseAlpha<0){textObj.baseAlpha=0;textObj.alphaDirection=1;}
  // Ensure consistent smooth pulse: always between 0 → 1
  const color=textObj.color.replace("ALPHA",Math.max(0,Math.min(1,textObj.baseAlpha)));
  ctx.font=`bold ${textObj.size}px sans-serif`;
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillStyle=color;
  ctx.fillText(textObj.text,textObj.x,textObj.y);
}

/* ===== ANIMATION LOOP ===== */
function animate(){
  ctx.clearRect(0,0,w,h);
  drawStars();
  drawShootingStars();
  updateWorm();
  drawWorm();
  drawTextObj();
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
